\chapter{Methodology}
In this project, methodology are separated into 2 phases. The 1st phase are considered the preliminary phase where the literature review are done involving searching for and reading relevant articles that is closely related to this project's topic. The 2nd phase is the methodology related to recreating some simulations/plots from previous paper and generating new simulation results using the Python codes developed in this project. This chapter will be divided into 4 sections. The general methodological approach implemented in this project will be discussed in the 1st section. Next, the data collection methods will be discussed in the 2nd section. Furthermore, the methods of analysis will be presented in the 3rd section. Finally, this chapter will end with providing justifications for all the methodological choices in this project.

\section{General Methodological Approach}
This project's main objective is to study the behaviour of coherent superflash $I_{s}$ in a new type of medium that is a 3-level EIT-enabled medium. As far as the literature review for this project had been done, there is no research yet that had been done on this topic mentioned here. In terms of superflash researches, all of their setup only involved using a 2-level medium, none can be found to be using a 3-level EIT-possible medium \cite{Kwong2014, Kwong2015, Kwong2017, Kwong2020}. In term of the study of Electromagnetically Induced Transparency (EIT) itself, the referred articles is \cite{}. From all of these cited articles, 2 articles can be pointed out as the inspiration to this project that is \cite{Kwong2014} and \cite{jeong2010slow}. \cite{Kwong2014} provides the idea of studying the detuning spectrum of the forward-scattered intensity $I_{s}$ (which is basically the coherent superflash) while \cite{jeong2010slow} lay out the necessary details e.g. medium susceptibility $\chi$ and medium refractive index $n$ for a 3-level EIT-possible medium.\\

To achieve the aim of "discovering" new behaviour of coherent superflash in the 3-level EIT-enabled medium, the most important component is to generate the detuning spectrum for the forward-scattered intensity spectrum (Will be called $I_{s}$ spectrum from here on) in a 3-level EIT-possible medium. In terms of data types used in this project, all of it are primary data (e.g. temporal profile and detuning spectrum simulation plots) that are generated by the Python simulation code that were developed here. Nevertheless, the important parameters such as the incident pulse length and the medium parameters are adapted from \cite{jeong2010slow}.\\

The data collected consist of the simulation plots in the temporal and frequency domain. There's only one type of plot for the temporal domain. It is the simulation for the transmitted intensity. The code for this simulation will be discussed further in data analysis section. For the frequency domain data (e.g. detuning spectrum) there are 4 main simulations consisting of the $I_{s}(\Delta)$ spectrum, steady-state transmission spectrum $I_{ss}(\Delta)$, phase shifts $\phi(\Delta)$ and absorption coefficient $\alpha(\Delta)$. The study of the behaviour of coherent superflash was mainly focused on the EIT-switch parameter that is the coupling laser's Rabi frequency $\Omega_{c}$. This important parameter were varied and changes in the frequency-domain plots were observed. Then, through analysis, a hypothesis was proposed for the cause/mechanism of the observed changes.


\section{Data Collection Methods}
The data collection methods in this project involves simulating and generating the desired temporal and spectral profiles using Python programming language. Python programming language are chosen for developing the simulation code in this project because of our familiarity with it and its simplicity. So, in collecting the relevant plots, the completed Python codes were executed and the outputs consisting of a figure of a plot are recorded and saved in an organized folders. There are 5 main Python codes involved in this project and all of it are able to generate simulation for both 2-level (by setting $\Omega_{c} = 0$) and 3-level EIT medium (by setting $\Omega_{c} \neq 0$). The first code to plot the temporal profile for the transmitted intensity which is the most important one will be discussed in the first subsection here. This first code is the most crucial one because the data points in the second code for plotting the $I_{s}$ spectrum are extracted from iteration of the first code for different probe detuning. This will be discussed in detail in the second subsection. Next, in the third subsection, the third code involving plotting spectrum of the steady-state transmitted intensity $I_{ss}$ will be discussed. Afterwards, the fourth code that functions to plot the spectrum of the phase shift of the transmitted field $\phi$ will be elaborated in the fourth subsection. At last, the final code for plotting the spectrum of the absorption coefficient $\alpha$ will be discussed in the last subsection of this Methodology chapter.\\

As a final note, the code for each subsection are included in the appendices section for clarity.

\subsection{Simulating The Temporal Profile of The Transmitted Intensity $I_{t}$}\label{temporalProfile}
In simulating the transmitted intensity, there are 3 important aspects in the code. The first two aspects are closely-related to the physics and mathematical expression concerning the incident pulse and the medium. While the third aspect are related to the manipulation of the initial output array of the transmitted field into a final version through several lines in the code that can be seen in Appendix \ref{appendixA}.\\

Firstly, the transmitted field $E_{t}(t, z)$ are acquired by performing an Inverse Fast Fourier Transform (IFFT) on the frequency-domain transmitted field $E_{t}(\omega, z)$. IFFT is basically the numerical version of the analytical Inverse Fourier Transform (IFT). The FFT/IFFT-related procedure are executed using the built-in FFT/IFFT function in the Python's SciPy/NumPy module. The frequency-domain transmitted field can be expressed as Equation \ref{eqn: E(w, z)} according to \cite{jeong2006thesis}.

\begin{equation}
    E_{t}(\omega, z) = E_{0}(\omega, z) e^{i k(\omega) z}
    \label{eqn: E(w, z)}
\end{equation}

Where;

\begin{itemize}
    \item $E_{0}(\omega, z)$ is the frequency-domain incident field which is acquired by performing an FFT to the time-domain incident field $E_{0}(t, z)$
    \item $e^{i k(\omega) z}$ are called the Transfer function of the medium which characterize the medium response towards the incident field
    \item $k(\omega) = \frac{\omega_{0}}{c} n(\omega) = \frac{\omega_{0}}{c} \sqrt{1 + \chi(\omega)}$ is the complex wavenumber of the incident field. $\omega_{0}$ is the medium's resonant angular frequency.
\end{itemize}

Since the frequency-domain incident field $E_{0}(\omega, z)$ have been obtained from the FFT, we are left with specifying the explicit expression for $k(\omega)$ in the code through specifying the expression for $\chi(\omega)$. For EIT medium, $\chi(\omega)$ can be expressed as Equation \ref{eqn: chi(w)} according to \cite{Jeong2009, Braje2004}. After all of these are specified, the IFFT are performed giving us the "initial" time-domain transmitted field labeled as "E" in the code. This time-domain transmitted field are labeled as the initial one because it actually doesn't output the proper temporal profile when its intensity are plotted. The output will be an inverted temporal profile as shown in Figure \ref{fig: compare temporal}a while the correct one, Figure \ref{fig: compare temporal}b are produced after some manipulation of the initial transmitted electric field array.

\begin{figure}[h!]
    \centering
    \includegraphics[scale = 0.63]{Figures/compareTemporal2.PNG}
    \caption{Comparison between the temporal profile that is acquired a) before output array manipulation and b) after output array manipulation.}
    \label{fig: compare temporal}
\end{figure}

For the manipulation of the initial output array $E$, it is closely related to the ignition point, extinction point and the total duration of the pulse (including the instance where it is not switched-on). In determining the final form of the transmitted field array, the first step taken in the code is to find the element index number where the pulse is switched on (ignition) and switched off (extinction). In the code, both this important element index number are labeled as \textit{upIndex} and \textit{downIndex} for ignition point and extinction point respectively. Next is the part for "constructing" the final transmitted field array (Defined as "$Efinal$" in the code). To do this, it consist of carefully choosing 3 different sections of the initial electric field array $E$ depending on the \textit{upIndex}, \textit{downIndex} and the total number of data points in the whole transmitted electric field array defined as $N$ which throughout this project are set to $80,000$. The process of choosing the correct 3 sections of array for the final transmitted electric field array involve a short If-Else statements in the code. Finally, after all of of the above have been executed and programmed properly, we get the final transmitted electric defined as \textit{Efinal}. Then, to plot the transmitted intensity, the final transmitted electric field array are just squared and plotted against the time array which throughout this project, the pulse length is $2.5 \cdot 10^{-6}$ sec (including both the instance where pulse is on and off). The plotting is accomplished through one of Python's plotting module, the \textit{Matplotlib} module.

\subsection{Simulating The Forward-Scattered Intensity Spectrum $I_{s}$}\label{forwardScattered}
The process of plotting the $I_{s}$ spectrum involve finding the transmitted intensity $I_{t}$ at the extinction point for various different detunings. For example, the plot in Figure \ref{fig: compare temporal}b are the temporal profile for the resonant case ($\Delta = 0$). So, we vary this detuning starting from a negative detuning up (e.g. $\Delta = -30\gamma_{eg}$) till a positive detuning (e.g. $\Delta = 30\gamma_{eg}$) to create a symmetrically centered $I_{s}$ spectrum at $\Delta = 0$. For each of the temporal profile at a specific detuning, we find the max value of the transmitted intensity starting from the extinction point up to 200 data points in front of the extinction point. This maximum value are then assigned as one of the element in the $I_{s}$ spectrum array defined as \textit{IsArray} in the code. Not to forget, the x-axis for the plot which consists of all the detunings are put into an array defined as \textit{detuningArray} in the code. In term of code, this iteration of acquiring different value of $I_{s}$ for different detunings $\Delta$ are achieved through a simple While-Loop. The looping of this While-Loop depends on the value of the detuning. Meaning that, the initial detuning will be applied then incremented by a certain chosen value (Increment chosen is $2.5 \cdot 10^{6}$) at the end of the loop. Then, the loop condition is checked whether it is still satisfied. For the loop to continued, the detuning value must be in the range $-30\gamma_{eg}$ up till $30\gamma_{eg}$. Finally, after both the $I_{s}$ array (\textit{IsArray}) and the detuning $\Delta$ array (\textit{detuningArray}) has been completed, the plotting process are as usual using the Python's \textit{Matplotlib} module similar to what have been done in Section \ref{temporalProfile}.

\subsection{Simulating The Steady-State Transmitted Intensity $I_{ss}$}\label{steady}
To plot the steady-state transmitted intensity $I_{ss}$ is very simple compared to the previous 2 plots in Section \ref{temporalProfile} and \ref{forwardScattered}. As usual, the important parameters e.g. medium resonant wavelength and OD are defined. Next, the most important part is defining the susceptibility $\chi$ because it is part of the complex wavenumber $k(\Delta)$ where 2 times its imaginary part $2\Im{k(\Delta)}$ are defined as the medium's absorption coefficient ($\alpha(\Delta) = 2\Im{k(\Delta)}$). Then, according to \cite{boyd2020nonlinear}, the steady-state intensity is defined as;

\begin{equation}
    I_{ss}(\Delta, z) = I_{0} e^{-\alpha(\Delta) z}
    \label{eqn: Iss}
\end{equation}

Then, in the code, the detuning array are created with value from $-30\gamma_{eg}$ until $30\gamma_{eg}$ with a total of $453$ data points (This value is chosen to match the total number of data points generated for the $I_{s}$ array in Section \ref{forwardScattered}). For the steady-state intensity array defined as \textit{I} in the code, defined as in Equation \ref{eqn: Iss} (also assuming its normalized $I_{0} = 1$). Finally, with all of the above set up, the plot is easily and quickly generated using Python's \textit{Matplotlib} module. An example of its plot can be seen in Figure \ref{fig: steady}

\begin{figure}[h!]
    \centering
    \includegraphics[scale = 0.45]{Figures/steady.png}
    \caption{Caption}
    \label{fig: steady}
\end{figure}

\subsection{Simulating The Phase Shift of The Transmitted Field $\phi$}
For the phase shift, the x-axis, the detuning array are also identical to the one defined in Section \ref{steady}. The only difference is in the definition of phase shift. According to \cite{boyd2020nonlinear}, the phase of and electric field $\phi(\Delta, z)$ is defined as;

\begin{equation}
    \phi(\Delta, z) = \Re{k(\Delta)} z
    \label{eqn: phase}
\end{equation}

The phase shift is defined as the difference between the phase in Equation \ref{eqn: phase} and "resonant" phase of the electric field $k_{0}z$. So, as shown in the code, this difference between these 2 phases are defined as \textit{phaseShift} then for convenience, it is normalized with respect to $\pi$ defining a new variable \textit{phaseShiftNorm}. After this is acquired, the process of plotting are simple using again Python's \textit{Matplotlib} module. The \textit{phaseShiftNorm} array are plotted against \textit{detuningArrayNorm} (normalized \textit{detuningArray} with respect to $\gamma_{eg}$). An example of the plot are shown in Figure \ref{fig: phase}.

\begin{figure}[h!]
    \centering
    \includegraphics[scale = 0.4]{phase.png}
    \caption{Caption}
    \label{fig: phase}
\end{figure}

\subsection{Simulating The Absorption Coefficient of The Medium}
Finally, for the absorption coefficient, the detuning array are also completely identical to the one discussed in previous sections. The normalized detuning array that will be used as the x-axis is defined as \textit{detuningArrayNorm}. For the absorption coefficient, it's defined according to \cite{boyd2020nonlinear};

\begin{equation}
    \alpha(\Delta) = 2 \Im{k(\Delta)}
\end{equation}

Using the above definition for absorption coefficient. We defined in the code \textit{absCoeff} as the absorption coefficient. Finally, using these 2 constructed arrays, \textit{absCoeff} is plotted against \textit{detuningArrayNorm} utilizing Python's \textit{Matplotlib} module. An example of the generated plot are shown in Figure \ref{fig: abs}.

\begin{figure}[h!]
    \centering
    \includegraphics[scale = 0.45]{Figures/abs.png}
    \caption{Caption}
    \label{fig: abs}
\end{figure}


\section{Data Analysis Methods}
\subsection{Descriptive Data Analysis}
The change in the $I_{s}$ spectrum between a 2-level medium and a 3-level EIT medium were observed and recorded. This is to visualize and answer what is the difference when the type of medium are changed. For example, the main change that were observed going from $\Omega_{c} = 0$ to $\Omega_{c} = 4.2\gamma_{eg}$ is the introduction of a new fluctuation in the $I_{s}$ spectrum near the resonance. This change can be seen in Figure \ref{fig: compare Is spectrum}. 

\subsection{Exploratory Data Analysis}
The initial change observed when enabling EIT in the 3-level medium as shown in Figure \ref{fig: comparing Is spectrum} occurred when the coupling laser's Rabi frequency are varied to a constant non-zero value. Next, we varied this value of coupling laser's Rabi frequency $\Omega_{c}$ to explore further change that could be observed in the structure of the $I_{s}$ spectrum. From this, some of the different outputs of the $I_{s}$ spectrum for different $\Omega_{c}$ were compiled in Figure \ref{fig: compare Is spectrums}. It is observed that, not only that enabling EIT introduced new fluctuations near resonance but as the EIT parameter ($\Omega_{c}$) were increased, the structure of the $I_{s}$ spectrum also change. It "widens" causing the initial fluctuation near resonance to be more resolved. Other than that, it is observed that the 2 global maxima peaks of the $I_{s}$ spectrum move further away from resonance resulting to the increase of its detuning value at that global maxima point. Further details of this observation are discussed in Section \ref{results and analysis}.


\section{Reliability and Viability of The Methodological Choices}
The main methodological choices made in this project is to use Python programming language as the main tool to discover new behaviour of the $I_{s}$ spectrum in a 3-level EIT medium and to further use it to explore and study the relationship between the $I_{s}$ spectrum with many other parameters such as the coupling laser's Rabi frequency $\Omega_{c}$, the optical depth (OD) and the probe detuning $\Delta$. Still, the main focus for this project is the relationship with the EIT parameter $\Omega_{c}$.\\

The reason Python programming language were chosen as a platform to develop the simulation codes are because of its FFT/IFFT functions in the \textit{Numpy} module. Other programming language e.g. Mathematica also have this kind of modules/packages but Python were chosen because our familiarity with the language and the its syntax simplicity. These FFT/IFFT are really important because it is used in acquiring the spectrum of the incident field $E_{0}(\Delta, z)$ which is a part in the expression for the spectrum of the transmitted field as shown in Equation \ref{eqn: E(w, z)}. In addition to that, IFFT function are then used for the most crucial part that is obtaining the time-domain transmitted field through IFFT of Equation \ref{eqn: E(w, z)}.\\

As discussed previously in Section \ref{precursor}, there are 2 main approaches in obtaining the transmitted field for a certain pulse propagation problem. The first method is the FFT/IFFT approach that was implemented in this project. The second method is the numerical asymptotic method. Both of these method are widely used by researcher either implementing one of the approach or combining both approaches. The reason FFT/IFFT approach was chosen for this project is because of its mathematical simplicity and ease of its application numerically. Furthermore, many of the numerical results from FFT/IFFT approach has been proven to be valid and agrees well with experimental data \cite{Chen2010, Macke2013, MacKe2009, Oughstun2010, Wei2009, Jeong2008, Jeong2010}. The numerical asymptotic method were not implemented for this project because of its mathematical complexity. Even though numerical asymptotic approach could also produce accurate and valid results, FFT/IFFT method still outweighs them because it can produce similar results with less theoretical complexity. Even then, numerical asymptotic analysis still have its own pros over the FFT/IFFT approach for example in studying optically thin medium when asymptotic approximation are applicable. An example of paper that implemented numerical asymptotic analysis in their research is \cite{Jeong2009}.\\

To summarize, FFT/IFFT approach are chosen for acquiring the transmitted field for this project over the numerical asymptotic method because of its theoretical simplicity and its widespread implementation in many other research papers with valid results that closely match the experimental results.
